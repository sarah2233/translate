#
# Copyright 2008 Zuza Software Foundation
#
# This file is part of translate.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.

"""
Fill localization files with suggested translations based on translation memory and existing translations.

This script provides automated translation suggestions for untranslated strings by:
1. Using existing translations from a template file (exact matches)
2. Using fuzzy matching to find similar strings from the template
3. Using a Translation Memory (TM) to find matches from previous translations
4. Supporting various file formats (PO, POT, XLF, XLIFF)

Key features:
- Template-based translation
- Fuzzy matching with configurable similarity threshold
- Translation Memory (TM) support
- Location-based and ID-based matching
- Support for multiple input formats
- Handling of special cases (Mozilla strings, OpenOffice formats)

See: http://docs.translatehouse.org/projects/translate-toolkit/en/latest/commands/pretranslate.html
for examples and usage instructions.
"""

from translate.search import match
from translate.storage import factory

# Global TM matcher to avoid reinitialisation
tmmatcher = None


def memory(tmfiles, max_candidates=1, min_similarity=75, max_length=1000):
    """
    Initialize and return the Translation Memory (TM) store.
    
    Creates a singleton TM matcher to avoid reinitializing on every call.
    
    Args:
        tmfiles: Single file or list of translation memory files
        max_candidates: Maximum number of translation candidates to return
        min_similarity: Minimum similarity percentage for fuzzy matches
        max_length: Maximum string length to consider for matching
    
    Returns:
        A matcher object configured with the specified TM store
    """
    global tmmatcher  # noqa: PLW0603
    # Only initialise first time
    if tmmatcher is None:
        if isinstance(tmfiles, list):
            tmstore = [factory.getobject(tmfile) for tmfile in tmfiles]
        else:
            tmstore = factory.getobject(tmfiles)
        tmmatcher = match.matcher(
            tmstore,
            max_candidates=max_candidates,
            min_similarity=min_similarity,
            max_length=max_length,
        )
    return tmmatcher


def pretranslate_file(
    input_file,
    output_file,
    template_file,
    tm=None,
    min_similarity=75,
    fuzzymatching=True,
):
    """
    Pretranslate a localization file using templates and translation memory.
    
    Args:
        input_file: Source file to be translated
        output_file: Where to write the pretranslated file
        template_file: Optional template with existing translations
        tm: Optional translation memory file
        min_similarity: Minimum similarity for fuzzy matches (0-100)
        fuzzymatching: Whether to perform fuzzy matching
    
    Returns:
        1 on success (for command-line usage)
    """
    input_store = factory.getobject(input_file)
    template_store = None
    if template_file is not None:
        template_store = factory.getobject(template_file)

    output = pretranslate_store(
        input_store, template_store, tm, min_similarity, fuzzymatching
    )
    output.serialize(output_file)
    return 1


def match_template_location(input_unit, template_store):
    """
    Find matching translation unit based on source locations.
    
    Special handling for Mozilla and OpenOffice files which use locations
    as unique identifiers. Checks for ':' in location to detect these formats.
    
    Args:
        input_unit: Unit to find match for
        template_store: Template store to search in
    
    Returns:
        Matching unit from template or None
    """
    # we want to use slightly different matching strategies for PO files
    # generated by our own moz2po and oo2po. Let's take a cheap shot at
    # detecting them from the presence of a ':' in the first location.
    locations = input_unit.getlocations()
    if not locations or ":" in locations[0]:
        return match_template_id(input_unit, template_store)

    # since oo2po and moz2po use location as unique identifiers for strings
    # we match against location first, then check for matching source strings
    # this makes no sense for normal gettext files
    for location in locations:
        matching_unit = template_store.locationindex.get(location, None)
        if (
            matching_unit is not None
            and matching_unit.source == input_unit.source
            and matching_unit.gettargetlen() > 0
        ):
            return matching_unit
    return None


def match_template_id(input_unit, template_store):
    """
    Find matching translation unit based on unit ID.
    
    Used as fallback when location matching fails or for formats
    that use IDs as primary identifiers.
    
    Args:
        input_unit: Unit to find match for
        template_store: Template store to search in
    
    Returns:
        Matching unit from template or None
    """
    return template_store.findid(input_unit.getid())


def match_source(input_unit, store_or_matcher):
    """
    Find exact matching translation unit based on source text.
    
    Special case: Skips matching single-letter strings in Mozilla format
    as these should only be matched by location.
    
    Args:
        input_unit: Unit to find match for
        store_or_matcher: Template store or matcher to search in
    
    Returns:
        Matching unit from template or None
    """
    source = input_unit.source
    if hasattr(source, "strings"):
        if len(source.strings) > 1:
            return None
    else:
        if len(source) <= 1:  # Skip single-letter strings
            return None

    # Skip fuzzy units
    if input_unit.isfuzzy():
        return None

    if hasattr(store_or_matcher, "findunit"):
        # It's a store, use findunit
        return store_or_matcher.findunit(source)
    elif hasattr(store_or_matcher, "candidates"):
        # It's a matcher, use candidates
        matches = store_or_matcher.candidates(source)
        if matches:
            return matches[0]
    elif hasattr(store_or_matcher, "units"):
        # It's a TM store, search through units
        for unit in store_or_matcher.units:
            if unit.source == source:
                return unit
    return None


def match_fuzzy(input_unit, matchers):
    """
    Find fuzzy matches using the provided matchers.
    
    Tries each matcher in sequence until a match is found.
    Used for both template and TM fuzzy matching.
    
    Args:
        input_unit: Unit to find fuzzy matches for
        matchers: List of matcher objects to try
    
    Returns:
        Best fuzzy match or None
    """
    for matcher in matchers:
        fuzzycandidates = matcher.matches(input_unit.source)
        if fuzzycandidates:
            return fuzzycandidates[0]
    return None


def pretranslate_unit(
    input_unit, template_store, matchers=None, mark_reused=False, merge_on="id"
):
    """
    Attempt to pretranslate a single translation unit.
    
    Matching process:
    1. Try template matching (location or ID based)
    2. Try exact source matching
    3. Try fuzzy matching with template and TM
    4. Add alternate translations for fuzzy matches if supported
    
    Args:
        input_unit: Unit to pretranslate
        template_store: Template with existing translations
        matchers: List of fuzzy matchers (template and TM)
        mark_reused: Whether to mark reused translations (for pot2po)
        merge_on: Matching strategy ('location' or 'id')
    
    Returns:
        The input unit, possibly modified with a translation
    """
    matching_unit = None

    # Do template matching
    if template_store:
        # :param:`merge_on` supports `location` and `id` for now
        if merge_on == "location":
            matching_unit = match_template_location(input_unit, template_store)
        else:
            matching_unit = match_template_id(input_unit, template_store)

    if matching_unit and matching_unit.gettargetlen() > 0:
        input_unit.merge(matching_unit, authoritative=True)
    elif matchers:
        # quickly try exact match by source
        matching_unit = match_source(input_unit, template_store)

        if not matching_unit or not matching_unit.gettargetlen():
            # do fuzzy matching
            matching_unit = match_fuzzy(input_unit, matchers)

        if matching_unit and matching_unit.gettargetlen() > 0:
            # Main loop through matchers
            for matcher in matchers:
                matching_unit = None
                if matcher == matchers[0]:
                    matching_unit = match_source(input_unit, matcher)
                else:
                    matching_unit = match_fuzzy(input_unit, [matcher])
                if matching_unit:
                    if template_store is not None:
                        # If we have a template, use alt-trans for TM matches
                        input_unit.addalttrans(
                            matching_unit.target, origin="fish", sourcetxt=matching_unit.source
                        )
                    else:
                        # If no template, use TM matches as primary translations
                        input_unit.target = matching_unit.target
                    break

    # FIXME: ugly hack required by pot2po to mark old
    # translations reused for new file. loops over
    if mark_reused and matching_unit and template_store:
        original_unit = template_store.findunit(matching_unit.source)
        if original_unit is not None:
            original_unit.reused = True

    return input_unit


def pretranslate_store(
    input_store, template_store, tm=None, min_similarity=75, fuzzymatching=True
):
    """
    Pretranslate an entire translation store.
    
    Process:
    1. Prepare template store (indexing, matcher creation)
    2. Prepare translation memory if provided
    3. Process each translatable unit
    4. Apply format-specific preparation if needed
    
    Args:
        input_store: Store containing units to translate
        template_store: Template with existing translations
        tm: Translation memory to use
        min_similarity: Minimum similarity for fuzzy matches
        fuzzymatching: Whether to perform fuzzy matching
    
    Returns:
        The pretranslated store
    """
    # preperation
    matchers = []
    # prepare template
    if template_store is not None:
        template_store.makeindex()
        # template preparation based on type
        prepare_template = f"prepare_template_{template_store.__class__.__name__}"
        if prepare_template in globals():
            globals()[prepare_template](template_store)

        if fuzzymatching:
            # create template matcher
            # FIXME: max_length hardcoded
            matcher = match.matcher(
                template_store,
                max_candidates=1,
                min_similarity=min_similarity,
                max_length=3000,
                usefuzzy=True,
            )
            matcher.addpercentage = False
            matchers.append(matcher)

    # prepare tm
    # create tm matcher
    if tm and fuzzymatching:
        # FIXME: max_length hardcoded
        if isinstance(tm, str):
            tm = factory.getobject(tm)
        if hasattr(tm, "makeindex"):
            tm.makeindex()
        # For TMX files, we'll search through units directly
        if hasattr(tm, "units"):
            # Create a Levenshtein comparer for fuzzy matching
            comparer = match.lshtein.LevenshteinComparer(1000)
            
            # Main loop
            for input_unit in input_store.units:
                if input_unit.istranslatable():
                    best_match = None
                    best_similarity = 0
                    
                    # Try exact matches first
                    for tm_unit in tm.units:
                        if tm_unit.source == input_unit.source:
                            input_unit.target = tm_unit.target
                            best_match = None  # Clear best match since we found exact
                            break
                        elif fuzzymatching:
                            # If no exact match, try fuzzy matching
                            # Convert multistrings to strings for comparison
                            tm_source = str(tm_unit.source).lower().strip('!.?')
                            input_source = str(input_unit.source).lower().strip('!.?')
                            # Skip very different length strings
                            if abs(len(tm_source) - len(input_source)) > min(len(tm_source), len(input_source)) * 0.5:
                                continue
                            similarity = comparer.similarity(tm_source, input_source)
                            if similarity > best_similarity and similarity >= min_similarity:
                                best_similarity = similarity
                                best_match = tm_unit
                    
                    # If we found a good fuzzy match, use it
                    if best_match:
                        input_unit.target = best_match.target
                        input_unit.markfuzzy(True)  # Mark as fuzzy since it's not exact
            
            return input_store

    # Main loop
    for input_unit in input_store.units:
        if input_unit.istranslatable():
            # If we have no template but have TM matches, use them directly
            if template_store is None and matchers:
                for matcher in matchers:
                    # Try exact match first
                    matching_unit = match_source(input_unit, matcher)
                    if not matching_unit and fuzzymatching:
                        # Try fuzzy match if no exact match
                        matching_unit = match_fuzzy(input_unit, [matcher])
                    if matching_unit and matching_unit.gettargetlen() > 0:
                        input_unit.target = matching_unit.target
                        break
            else:
                # Use normal template-based matching
                pretranslate_unit(
                    input_unit, template_store, matchers, merge_on=input_store.merge_on
                )

    return input_store


def main(argv=None):
    """
    Command-line interface for the pretranslate tool.
    
    Features:
    - Supports multiple input/output formats
    - Optional template file usage
    - Translation memory integration
    - Configurable fuzzy matching
    - Similarity threshold setting
    
    Command-line options:
    --tm: Translation memory file
    -s/--similarity: Minimum similarity percentage
    --nofuzzymatching: Disable fuzzy matching
    """
    from translate.convert import convert

    formats = {
        "pot": ("po", pretranslate_file),
        ("pot", "po"): ("po", pretranslate_file),
        "po": ("po", pretranslate_file),
        ("po", "po"): ("po", pretranslate_file),
        "xlf": ("xlf", pretranslate_file),
        ("xlf", "xlf"): ("xlf", pretranslate_file),
        "xliff": ("xliff", pretranslate_file),
        ("xliff", "xliff"): ("xliff", pretranslate_file),
    }
    parser = convert.ConvertOptionParser(
        formats, usetemplates=True, allowmissingtemplate=True, description=__doc__
    )
    parser.add_option(
        "",
        "--tm",
        dest="tm",
        default=None,
        help="The file to use as translation memory when fuzzy matching",
    )
    parser.passthrough.append("tm")
    defaultsimilarity = 75
    parser.add_option(
        "-s",
        "--similarity",
        dest="min_similarity",
        default=defaultsimilarity,
        type="float",
        help="The minimum similarity for inclusion (default: %d%%)" % defaultsimilarity,
    )
    parser.passthrough.append("min_similarity")
    parser.add_option(
        "--nofuzzymatching",
        dest="fuzzymatching",
        action="store_false",
        default=True,
        help="Disable fuzzy matching",
    )
    parser.passthrough.append("fuzzymatching")
    parser.run(argv)


if __name__ == "__main__":
    main()
